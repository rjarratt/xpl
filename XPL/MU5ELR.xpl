*SEGMENT 8192
BEGIN
:: This is Robert Jarratt's re-construction of a minimal MU5 Engineer's Loader. It bears little resemblance to the original functionality at this stage.
::
:: The vectors below are the interrupt vectors, with space for the old link and values for the new link. The segment must be loaded as a virtually
:: addressed segment with a CPR set up for it. The new link values set executive mode in MS and keep virtual addressing enabled, so a CPR must be
:: coded for the interrupt handlers. The new link sets NB to zero, this assumes the interrupt procedures set SN to an executive data segment. The 
:: CO register is set to JUMP instructions at the start of segment 8193.
DATAVEC PAD(64)
0,[16]
END
DATAVEC VECTORS(64)
0, %001D000040020000
0, %001D000040020003
0, %001D000040020006
0, %001D000040020009
0, %001E00004002000C
0, %001E00004002000F
0, %001E000040020012
0, %001E000040020015
END
END
*END OF SEGMENT
*SEGMENT 8193
BEGIN
JUMP HANDLE.INTERRUPT.0
JUMP HANDLE.INTERRUPT.1
JUMP HANDLE.INTERRUPT.2
JUMP HANDLE.INTERRUPT.3
JUMP HANDLE.INTERRUPT.4
JUMP HANDLE.INTERRUPT.5
JUMP HANDLE.INTERRUPT.6
JUMP HANDLE.INTERRUPT.7
DATASTR INTERRUPT.0 "SYSTEM ERROR INTERRUPT|0D||0A|"
DATASTR INTERRUPT.1 "CPR NON-EQUIVALENCE INTERRUPT|0D||0A|"
DATASTR INTERRUPT.2 "EXCHANGE INTERRUPT|0D||0A|"
DATASTR INTERRUPT.3 "PERIPHERAL WINDOW INTERRUPT|0D||0A|"
DATASTR INTERRUPT.4 "INSTRUCTION COUNTER 0 INTERRUPT|0D||0A|"
DATASTR INTERRUPT.5 "ILLEGAL ORDERS INTERRUPT|0D||0A|"
DATASTR INTERRUPT.6 "PROGRAM FAULTS INTERRUPT|0D||0A|"
DATASTR INTERRUPT.7 "SOFTWARE INTERRUPT|0D||0A|"

V32/STK STACK.TOP:0
VV/0 PROGRAM.FAULT.STATUS:%100
VV/0 SYSTEM.ERROR.STATUS:%101
VV/0 EXIT.0:%10
VV/0 EXIT.1:%12
VV/0 EXIT.2:%14
VV/0 EXIT.3:%16
VV/0 EXIT.4:%18
VV/0 EXIT.5:%1A
VV/0 EXIT.6:%1C
VV/0 EXIT.7:%1E
VV/0 SF.0:%20
VV/0 SF.1:%22
VV/0 SF.2:%24
VV/0 SF.3:%26
VV/0 SF.4:%28
VV/0 SF.5:%2A
VV/0 SF.6:%2C
VV/0 SF.7:%2E

PROC HANDLE.INTERRUPT.0
SF => SF.0
SF = 0
SN = %20020000
STACK A

ACALL PRINT.STRING(L0,INTERRUPT.0)
L0:
A =' 0
A => SYSTEM.ERROR.STATUS
AOD = 0

A = STACK.TOP
SN = SF.0
SF = SF.0

EXIT EXIT.0
END

PROC HANDLE.INTERRUPT.1
SF => SF.1
SF = 0
SN = %20020000
STACK A

ACALL PRINT.STRING(L1,INTERRUPT.1)
L1:
A =' 0
A => SYSTEM.ERROR.STATUS

A = STACK.TOP
SN = SF.1
SF = SF.1

EXIT EXIT.1
END

PROC HANDLE.INTERRUPT.2
SF => SF.2
SF = 0
SN = %20020000
STACK A

ACALL PRINT.STRING(L2,INTERRUPT.2)
L2:
A =' 0
A => SYSTEM.ERROR.STATUS
A = STACK.TOP

SN = SF.2
SF = SF.2

EXIT EXIT.2
END

PROC HANDLE.INTERRUPT.3
SF => SF.3
SF = 0
SN = %20020000
STACK A

ACALL PRINT.STRING(L3,INTERRUPT.3)
L3:
A =' 0
A => SYSTEM.ERROR.STATUS

A = STACK.TOP
SN = SF.3
SF = SF.3

EXIT EXIT.3
END

PROC HANDLE.INTERRUPT.4
SF => SF.4
SF = 0
SN = %20020000
STACK A

ACALL PRINT.STRING(L4,INTERRUPT.4)
L4:
A =' 0
A => PROGRAM.FAULT.STATUS

A = STACK.TOP
SN = SF.4
SF = SF.4

EXIT EXIT.4
END

PROC HANDLE.INTERRUPT.5
SF => SF.5
SF = 0
SN = %20020000
STACK A

ACALL PRINT.STRING(L5,INTERRUPT.5)
L5:
A =' 0
A => PROGRAM.FAULT.STATUS

A = STACK.TOP
SN = SF.5
SF = SF.5

EXIT EXIT.5
END

PROC HANDLE.INTERRUPT.6
SF => SF.6
SF = 0
SN = %20020000
STACK A

ACALL PRINT.STRING(L6,INTERRUPT.6)
L6:
A =' 0
A => PROGRAM.FAULT.STATUS
AOD = 0

A = STACK.TOP
SN = SF.6
SF = SF.6

EXIT EXIT.6
END

PROC HANDLE.INTERRUPT.7
SF => SF.7
SF = 0
SN = %20020000
STACK A

ACALL PRINT.STRING(L7,INTERRUPT.7)
L7:
A =' 0
A => PROGRAM.FAULT.STATUS

A = STACK.TOP
SN = SF.7
SF = SF.7

EXIT EXIT.7
END

:: Parameter is descriptor for string to be printed.
PROC PRINT.STRING
V64/NB STRING:1
V32/NB LENGTH:4
VV/0 CONSOLE.INTERRUPT:%300
VV/0 TELETYPE.DATA:%306
VV/0 TELETYPE.CONTROL:%307

NB =SF+ - 2 :: Go back 2 for each parameter
SF + 1

STACK B
STACK D
STACK A

:: Extract length of string              
A =' STRING
AU <= -32
AU & %FFFFFF
A => LENGTH

B = 0
D = STRING
NEXTCHAR:
B COMP LENGTH
IF >=0, - -> DONE
A =' %F                       :: Value that resets console interrupt bits
A => CONSOLE.INTERRUPT        :: Set Console Interrupt in Console V-Store
A =' %00                      :: TTY output mode
A => TELETYPE.CONTROL         :: Set teletype control
A =' D[B]                     :: Next character
A => TELETYPE.DATA            :: Set teletype data

POLL: A =' CONSOLE.INTERRUPT  :: Read Console Interrupt
AU COMP 0                     :: Poll for interrupt
IF =0, - -> POLL
B + 1
- -> NEXTCHAR

DONE:
A = STACK.TOP
D = STACK.TOP
B = STACK.TOP

RETURN
END

END
*END OF SEGMENT
